# cache-v1 tetctf
### Analysis

struct of cache:
```c++
struct cache {
    char *base;
    size-t size;
    cache() : base(nullptr), size(0) {}
    virtual ~cache() {
        if (base != nullptr) {
            delete[] base;
            base = nullptr;
        }
    }
};
```

global map to keep tracks on caches and global set to keep tracks on list exist names
```c++
std::unordered-set<std::string> usedNames;  // stores exist names
std::unordered-map<size-t, cache> caches;   // stores list caches
``` 

function create:
- read name and check whether it exists using `usedNames.count(name)`
- size != 0 and size < 0x1000000
- hash name using `std::hash::string>{}(name)` and use as index in caches and usedNames
- `caches[std::hash<std::string>{}(name)].size = size;` set size of a cache

function read:
- read name and check whether it exists using `usedName.count(name)`
- check caches.base == nullptr -> no data
- if offset >= caches[hash].size -> invalid
- read count, if offset + count >= cashes[hash].size -> invalid
- `std::cout.write(caches[hash].base + off, n);`

function write:
- check name exists using `usedNames.count(name)`
- if offset >= cashes[hash].size -> invalid
- read count, if offset + count >= cashes[hash].size -> invalid
- if cashes[hash].base == nullptr -> call
```c++
caches[hash].base = new char[caches[hash].size];
memset(caches[hash].base, 0, caches[hash].size);
```
- read using: `std::cin.read(caches[hash].base + off, n);`

function erase: 
- check name exists
- erase using:
```c++
usedNames.erase(name);
caches.erase(std::hash<std::string>{}(name));
```

- seccomp allows: open, read, write, close, brk, mmap, exit-group

### Vulnerability:
- in function create, it checks name exists or not. If not exists it insert name to `usedNames` and set `caches[std::hash<std::string>{}(name)].size = size;` -> we can overwrite size of an exist name -> oob write and read

- heap is not allocated in function create, it is allocated in function write using `caches[hash].base = new char[caches[hash].size];`  
### Exploit:
#### Setup chunks:
- Create a small cache to collide   0x30
- Create 2 chunks which go to tcache (why we need 2 chunks to tcache when we can overwrite fd pointer?? -> need to bypass count check of tcache-struct :D)    0x80 * 2
- Create a large chunk to unsorted bin  0x1000
- Create a chunk to avoid merge with top chunk 0x20  
- Create a very large chunk which overlap small cache 0x2000

#### leak libc:
- Using fd pointer from unsorted bin to leak

#### Rip control
- Since we can control tcache fd pointer, overwrite `free_hook` with call gadget 
